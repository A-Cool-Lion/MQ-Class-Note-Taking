注释：用于解释说明程序的文字（提高程序的可读性）

单行注释（可以嵌套）：格式：*//注释文字*

多行注释（不能嵌套）：格式：*/\* 注释文字 \*/*

文档注释：格式：*/\*\* 注释文字 \*/*

关键字：被java语言赋予特定含义的单词 特点：组成关键字的字母全部小写

注意事项：**goto**和**const**作为保留字存储，目前不使用

标识符：给类、接口、方法、变量等起名字时使用的字符
组成规则：英文大小写字母、数字字符、\$和\_

注意事项：不能以数字开头、不能是java中的关键字、区分大小写

常见命名规则：

包名：要求全部小写，一般是公司域名倒着写（www.baidu.com→com.baidu.包的作用）

类或接口：如果是一个单词，要求首字母大写，如果是多个单词要求每个单词首字母大写（驼峰命名）

方法和变量：如果是单词，每个字母都小写，如果是多个单词，从第二个单词开始首字符大写（main，getName）

常量：如果是一个单词，所有字母大写，若果是多个单词也是所有字母大写，但是用下划线”_”分开

常量：在程序执行过程中的值不发生变化

种类：字符串常量（用双引号括起来的内容）、整数常量（所有整数）、小数
常量（所有小数）、字符常量（用单引号括起来的内容，里面只能放单个数
字，单个字母或单个符号且必须有内容[需要代表字符]）、布尔常量（true，
false）、空常量（null）、自定义常量

进制

进位制，一种规定的进位方法，对于任何一种进制→x进制，表示某一位置
上的数运算时逢x进一位，二进制就是逢二进一，八进制就是逢八进一等。

不同进制表现形式：

二进制：由0，1组成，以0b（b可以大写也可以小写）开头

八进制：由0、1、…7组成，以0开头

十进制：由0、1、…9组成，整数默认是十进制

十六进制：由0、1、…9、a、b、c、d、e、f（大小写均可）以0x开头

任意进制转十进制：

公式：

系数：每一位上的数据

基数：X进制，基数就是X

权：在右边，从0开始编号，对应位上的编号即为该位的权

结果：把系数\*基数的权次幂相加即可

十进制→十进制：

12345=10000+2000+300+40+5

=1\*10\^4+2\*10\^3+3\*10\^2+4\*10\^1+5\*10\^0

二进制→十进制：

0b100 = 1\*2\^2+0\*2\^1+0\*2\^0=4

八进制→十进制：

0100=1\*8\^2+0\*8\^1+0\*8\^0=64

十六进制→十进制

0x100=1\*16\^2+0\*16\^1+0\*16\^0=256

十进制到任意进制转换：

公式：除积倒取余（余数从下往上读）

十进制→十进制 12345(12345)

十进制→二进制 60(111100)

十进制→八进制 60(074)

十进制→十六进制 60(0x3c)

快速进制转换法：8421码及特点：8421码是中国大陆的叫法，
8421是BCD代码中最常见的一种，在这种编码方式中每一位二值代
码的1都是代表一个固定数值，把每一位的1代表的十进制数加起 来，得到的结
果就是它所代表的十进制数码

二进制→八进制简易方式：每三位划分为一位求值

二进制→十六进制简易方式：每四位划分为一位求值

十进制→二进制：将十进制值和二进制的8421码比较，依次减获取值

原码

二进制定点表示法，即最高位为符号为，”0”表示正，“1”表示负数其
余位表示数值大小，通过一个字节，也就是8个二进制表示+7（0[符号位]
0000111）和-7（1[符号位] 0000111）

反码

正数的反码与其相同；负数反码是对其原码逐位取反，但符号位除外

补码

正数的补码与其相同；负数的补码是在其反码的末位加1

变量 在程序执行的过程中，在某个范围内其值可以发生改变的量

定义格式：数据类型 变量名= 变量值；（存放统一类型的常量，可以重 复使用）

数据类型概述

JAVA语言是强类型语言，对于每一种数据都定义了明确的具体数据类型，在内存中分配了不同大小的内存空间

数据类型的分类：基本数据类型，引用数据类型

基本数据类型：

整数型：

byte占一个字节 -128 - 127

short占两个字节 -2\^15 - 2\^15-1

int 占四个字节 -2\^3 - 2\^31-1（整数默认的数据类型）

long占八个字节 -2\^63 - 2\^63-1 （数据后添加L或l[建议大写，小
写与1类似，不好区分]）

浮点型：

**float**占四个字节 -3.403E38 - 3.403E38 (单精度)（数据后添加F 或f进行标示）

double占把八个字节 -1.798E388 – 1.798 E388（双精度）（小数 默认的数据类型）

字符型

char占两个字节 0 – 65535(默认初始化值’\\u0000’，每个0表示
的是16进制的0[16进制是四位],char在内存中占的两个字节是 16个二进制位)

布尔型：boolean，理论上占八分之一个字节，因为一个开关就可以决
定是true和false了，但是java没有明确指定大小

变量使用注意事项

作用域问题：同一区域不能使用相同的变量名

初始化问题：局部变量在使用之前必须赋值

一条语句可以定义几个变量：多个变量

数据类型转换

隐式转换：**byte**+**int int**接收：先将**byte**提升为**int**，**int**相加结果为
**int byte**接受：编译不通过（从**int**转换到**byte**可能会有损失）

强制转换：**byte**+**int**
强制转换为**byte**类型(**byte**)(**byte**+**int**),如果超出了
被赋值的数据类型的取值范围得到的结果会与期望结果不同（精 度损失[溢出]）

变量和常量相加的区别

实例： **byte b1** = 3； **byte b2** = 4*;*

**byte b3** = **b1+b2;(编译不通过)**

从两方面回答问题：

1，b1和b2是两个变量，变量里面存储的值都是变化的，所以在程序运行中JVM是无法判断里面的具体的值

2，**byte**类型的变量在进行运算的时候，会自动类型提升为**int**类，两个**int**相加结果也是**int**型byte4
= 3+4；(编译通过) java编译器有常量优化机制

long与float的取值范围谁大谁小？

进行混合运算的时候，byte、short、char不会相互转换，都会自动类
型提升为int类型，其他类型进行混合运算的是小的数据类型提为大的

byte、short、char---int---long---**float**---double

long：8个字节 **float**：4个字节

（**float**占4个字节由IEEE 754规定32个进制位：1位代表符号位，
8为代表指数位[00000000-11111111→0（代表0）-255（代表无穷大）
剩下1-254都减去127则：-126-127，因此**float**的取值范围比long
要大]，23为代表位数位）

字符和字符串参与运算 任何数据类型用+与字符串相连接都会产生新的字符串

**System**.out.println(“**hello**”+’**a**’+1); 输出：**helloa1**

**System**.out.println(‘**a**’+1+”**hello**”); 输出：98**hello**

char数据类型 charc = 97；→a （0-65535）

java语言中字符char可以存储一个中文汉字，因为java语言采用的是
Unicode编码，Unicode编码中的每个字符占用两个字节，中文也是两个字 节

算术运算符的基本用法 运算符：对常量和变量进行操作的符号

运算符的分类：算术运算符，赋值运算符，比较运算符，逻辑运算符，位
运算符，三目运算符

算术运算符：+、-、\*、/、%（取余）、++、--

注意事项：

\+号在java中有三种作用：代表正号，做加法运算，字符串的连接符

整数除以整数智能得到整数，如果想要得到小数，必须把数据变化为 浮点小数类型

%运算符：

当左边绝对值小于右边绝对值时，结果是左边 （-12%5）

当左边绝对值等于右边或是右边倍数时，结果是0

当左边绝对值大于右边绝对值是，结果是余数

%运算符结果的符号只和左边有关系，与右边无关

任何一个正整数%2结果不是0就是1可以用来当做切换调节

算术运算符++和--的用法

\++*：自加，对原有的数据进行*+*1，*--*：自减，对原有的数据进行*-*1（会自
动强转）*

*单独使用：放在操作数前面和后面效果一样*

*参与运算：放在操作数前面，先自增或自减，然后再参与运算放在操作数
后面，先参与运算，再自增或自减*

赋值运算符的基本用法

基本的赋值运算符：=（**int** s = 0；把=右边的数据赋值给左边的变量）

扩展的赋值运算符：+=，-+，\*=，/=，%=（+= 把左边和右边做加法，然后 赋值给左边）

关系运算符的基本用法

种类：（比较运算符，条件运算符）==，!=，\>，\>=，\<=，\<

注意事项：无论操作简单还是复杂其结果是boolean类型，”==”不能写 成”=”

逻辑运算符的基本用法

&（有false则false），\|（有true则true），！（非false则true，非 true
则false，），\^（相同为false，不同为true），&&（短路），\|\| （短 路）

注意事项：逻辑运算符一般用于连接Boolean类型的表达式（用运算符把
常量或者变量连接起来的复合java语法的式子）或者值

&和&&区别：最终结果一样，&&具有短路效果，左边是false，右边则不执
行（\|\|和\|效果也是如此）

位运算符的基本用法

&（有0则0），\|（有1则1），\^（相同则0，不同则1）,\~（按位取反）

\^的特点：一个数据对另一个数据位亦或两次，该数据本身不变

x=10，y=5不使用第三方变量进行交换：x=x\^y,y=x\^y,x=x\^y;

\<\<：左移 左边最高位丢弃，右边补齐0（向左移动几位就是乘以2的几次 幂）

\>\>：右移 最高位是0，左边补齐0；最高位是1，右边补齐1（除2的几次 幂）

\>\>\>：无符号右移 无论最高位是0还是1，右边补齐0（有效计算 2\*8→2\<\<3）

三元运算符的基本用法

格式：（关系表达式）？表达式1：表达式2；

先计算关系表达式，如果关系表达式是true则使用表达式1，否则使用表 达式2

键盘录入的基本格式

a：导包，格式：**import** java.util.Scanner;(在**class**类上面)

b：创建键盘录入对象，格式：Scanner sc = **new** Scanner(System.**in**);

c：通过对象获取数据，格式：**int** x = sc.nextInt();(如需获取多个参
数，在控制面板回车后输入，获取的格式不变如**int** y = sc.nextInt())

顺序结构语句

流程控制语句：可以控制程序执行流程

流程控制语句的分类：顺序结构，选择结构，循环结构

执行流程：从上往下，依次执行

选择结构

分类 ：**if**语句，**switch**语句

**if**语句格式：三种格式（**if**（）{}、**if**（）{}**else**{}、**if**（）{}**else
if**（）{}**else**{}）

**if**(比较表达式){//先计算表达式，返回true执行语句体，否则不执行

语句体;

}

switch语句格式：

**switch**(表达式){ *//先计算表达式的值，然后和case匹配，如果有则执-*

**case**值1： *//-相应的语句，如果没有则执行default控制语句*

**break**; *//基本数据类型可接收：byte，short，char，int*

**case** 值2： *//引用数据类型可接收：枚举（JDK1.5），String （JDK1.7）*

**break**;

**default**:

**break**;

}

switch注意事项：

1：case后面只能是常量，不能是变量，而且多个case后面不能出现相同值

2：default可以省略，但不建议，因为它的作用是对不正确情况给出提示,可以在任意位置，但建议在最后

3：break最后一个可以省略，其他最好不要省略，因为switch语句遇到break才会退出（case穿透）,如下实例b的最终结果为2

**int** x=1；**int** b = 0;

switch(x){

case 1:

\++b;

*// break;*

case 2:

\++b;

break;

default:

b=-1;

break; }

System.out.println("b="+b);

4：switch结束条件：遇到break就结束，执行到switch的右大括号就结束

switch和if的区别：switch建议判断固定值的时候使用，if建议判断区间或范围的时候使用

循环结构

循环结构的分类：**for**、**while**、**do**…**while**

循环结构**for**语句的格式：

**for**(初始化表达式;条件表达式;循环后的操作表达式){

循环体;

}

执行流程：1：执行初始化语句

2：执行判断条件语句，看其返回值是true还是false如果是
true，就继续执行，如果是false，结束循环

3：执行循环体语句；

4：执行循环后的操作表达式

5：回到2继续；

获取一个数x的各个位上的值：x/10\^y%10(y是位数，如果是十位就是1)

循环结构**while**语句的格式：

初始化语句;

**while**(判断条件语句){

循环体语句;

控制条件语句;

}

执行流程：

1：执行初始化语句

2：执行判断条件语句，看其返回值是true还是false

如果是true，就继续执行，如果是false，结束循环

3：执行循环体语句；

4：执行控制条件语句；

5：回到2继续

循环结构do…while语句的格式：

初始化语句;

**do**{

循环体语句;

控制条件语句；

}**while**(判断条件语句)

执行流程：1：执行初始化语句

2：执行循环体语句；

3：执行控制条件语句；

4：执行判断条件语句，看其返回值是true还是false

如果是true，就继续执行，如果是false，结束循环

5：回到2继续；

**do**…**while**语句无论条件满不满足都会被执行一次

循环结构三种循环语句的区别：

1：**do**…**while**循环至少执行一次循环体，而**for**、**while**循环必须先判断条件是否成立，然后决定是否执行循环体语句

2：**for**和**while**的区别：**for**语句执行后初始化语句被释放（可以提高内存的使用效率），**while**语句执行后，初始化变量还可以再次使用

3：循环结构一定要注意控制条件语句所控制的变量，不要弄丢，否则容易出现死循环

控制跳转语句break语句

**break**只能在**switch**和循环中（跳出循环体）

控制跳转语句continue语句

**continue**只能在循环中使用（终止本次循环，继续下次循环）

控制跳转语句标号

一般用来跳出外层循环；

a: **for**(int i=1;i\<10;i++){

System.out.println("i ="+i);

b: **for**(int j=1;j\<8;j++){

System.out.println("j ="+j);

break a;

}

} 输出：i=1 j=1

控制跳转语句return

**return**的作用是返回，不是结束循环的而是结束方法的

方法概述和格式说明

方法：完成特定功能的代码块，提高代码的复用性

方法的格式：

修饰符 返回类型 方法名(参数类型 参数名1,参数类型 参数名2...){

方法体语句;

**return** 返回值；

}

示例：

**public int** getSum(**int** a,**int** b){

**int sum** = a+b;

**return sum**;

}

修饰符(public)：后面详解

返回值类型(int)：功能结果的数据类型

方法名(getSum)：符合命名规则的标识符，方便调用

参数：

实际参数(调用传入的参数)：实际参与运算的

形式参数(a,b)：方法定义上的，用于接收实际参数

参数类型(int)：参数的数据类型

参数名(a,b)：变量名

方法体语句(int sum = a+b;)：完成功能的代码

reture：结束方法

返回值(sum)：功能的结果，由return带给调用者

方法使用的注意事项

一般来说比较推荐赋值调用，可以针对结果进一步操作

方法不调用则不执行，方法与方法之间是平级关系，不能嵌套定义

方法定义的参数之间用逗号隔开，如果方法有返回值，一定要有**return**带回一个值

方法调用的时候不用再传递数据的类型，只需传递实际数据即可

方法重载概述和基本使用：

方法重载：在同一个类中，方法名相同，参数列表不同（参数个数不同,参数类型不同，参数顺序不同[一般开发中不用]）与返回值类型无关

数组概述和定义格式说明

数组：存储同一种数据类型多个元素的集合，可以看成是容器，可以存储基本数据类型，也可以存储引用数据类型

数组定义格式：数据类型[] 数组名 = new 数据类型[数组的长度];

数据的初始化：

数组的初始化：为数组开辟连续的内存空间，并未每个数组元素赋予值

动态初始化：只指定长度，由系统给出初始化值

格式：数据类型[] 数组名 = new 数据类型[数组的长度];

**int**[]arr = **new int**[5];

静态初始化：给出初始化值，有系统决定长度

格式：数据类型[] 数组名 = new 数据类型[]{元素1,元素2,…};

简化格式：数据类型[] 数组名 = {元素1,元素2,…};

int[] arr = {1,2,3,4,5};

Java中的内存分配以及栈和堆的区别

栈：存储局部变量（定义在方法声明上和方法中的变量）

堆：存储**new**出来的数组或对象

方法区：代码区(字节码文件[.**class**文件]加载区域)

本地方法区：系统相关

寄存器：给cup使用

数组操作的两个常见问题：越界和空指针

空指针*(NullPointerException)*：数组以及不存在指向堆内存了，然而还用数组名去范文

越界*(ArrayIndexOutOfBoundsException)*：访问数组中不存在的索引，出现索引越界异常（）

数组遍历

遍历：依次取出收中的每一个元素

属性：arr.length数组的长度

最大索引：arr.length-1

**public static void** print(**int**[] arr){

for(**int** i = 0;i \< arr.length ;i++ ) {

System.out.print(arr[i]+ " ");

}

}

二维数组概述和格式 二维数组：在数组中定义了数组

格式：数据类型 数组名 [][] = new 数据类型[m][n];

或者：数据类型[] 数组名[] = new 数据类型[m][n];

或者：数据类型 数组名[][] = new数据类型[m][n];

int[][] arr = new int[3][2];

面向过程（c语言）

面向过程强调过程，第一步，第二步…（例如洗衣服：第一步：放洗衣粉 浸
泡，第二步：揉搓干净，第三步：漂洗拧干，第四步：晾晒…）

面向对象（java）

强调对象，只需调用对象，具体实现由对象处理（例如洗衣服：交给全自 动
洗衣机，具体操作由洗衣机处理）

面向对象思想特点

一种更符合我们思想习惯的思想，可以将复杂的事情简单化，将我们从执 行
者变了指挥官，角色发生了转换

面向对象设计：其实就是在管理和维护对象之间的关系

面向对象特征：封装，继承，多态

类与对象概述 类：是一组相关的属性和行为的集合 （比如：学生）

对象：是该类事物的具体体现（比如：具体的某一个学生就是对象）

属性：就是该事物的描述信息（事物身上的名词）

行为：就是该事物能够做什么（事物身上的动词）

java中最基本的单位就是类，java中用**class**描述事物也是如此

成员变量：事物属性（和定义变量一样，只不过位置是在类中方法外）

成员方法：事物行为（和定义方法一样，只是去掉了static）

类定义案例：

**class Student**{

学生属性

String name;

**int** age;

String gender;

学生行为

**public void study**(){

System.**out**.println(“学生学习”);

}

**public void sleep**(){

System.**out**.println(“学生睡觉”);

}

}

类的使用：

**class Demo_Student**{

**public static void main**(String[] args){

*//1，创建对象格式：类名 对象名= new 类名();*

Student s = **new** Student();

*//2，使用成员变量：对象名.变量名*

s.name = “Jack”;

*//3，使用成员方法：对象名.方法名(…)*

s.study();

}

}

成员变量和局部变量的区别 在类中的位置不同：

成员变量：在类中方法外

局部变量：在方法定义总或者方法声明上

在内存中的位置不同：

成员变量：在堆内存（成员变量属于对象，对象进堆内存）

局部变量：在栈内存（局部变量属于方法，方法进栈内存）

生命周期不同：

成员变量：随着对象的创建而存在，随着对象的消失而消失

局部变量：随着方法的调用而存在，随着方法的调用完毕而消失

初始化值不同：

成员变量：有默认初始化值

局部变量：没有默认初始化值，必须定义，赋值，然后才能使用

注意事项：局部变量可以和成员变量名称一样，在方法中使用的时候，采用的就近原则

匿名对象的概述和应用 匿名对象：没有名字的对象

应用：1，调用方法：仅仅只调用一次，调用多次不适合使用，匿名对象调用完毕就是垃圾，可以被垃圾回收器回收，这种写法有利于节省代码

2，匿名对象可以作为实际参数传递

封装的概述 封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式。

好处：隐藏实现细节，提供公共的访问方式，提高代码复用性，提高安全性。

封装原则：将不需要对外提供的内容都隐藏起来，把属性隐藏，提供公共方法对其访问。

private关键字的概述和特点
特点：是一个权限修饰符，可以修饰成员变量和成员方法，被其修饰的成
员只能在本类中被访问

**private**的应用：把成员变量用**private**修饰，提供对应的getXxx()和setXxx()方法

**private**仅仅是封装的一种体现形式,不能说封装就是私有

this关键字的概述和应用 特点：代表当前对象的引用；

应用：用来区分成员变量和局部变量重名

构造方法Constructor概述和格式 构造方法概述和作用
：给对象的数据（属性）进行初始化

构造方法格式特点：

方法名与类名相同（大小写也要与类名一致）

没有返回值类型，连**void**也没有

没有具体的返回值，但是有返回语句，格式：**return**;

构造方法不能用对象调用

在创建对象时，系统自动调用了构造方法

构造方法的重载及注意事项
重载:方法名相同,与返回值类型无关(构造方法没有返回值),只看参数列表

注意事项：

如果我们没有给出构造方法，系统将自动提供一个无参构造方法。

如果我们给出了构造方法，系统将不再提供默认的无参构造方法。

如果在给出构造方法，还想使用无参构造方法，就必须自己给出（建议永远自己给出无参构造方法）

成员变量赋值的两种方式的区别 setXxx()方法：修改属性值

构造方法：给对象中属性进行初始化

static关键字的特点 随着类的加载而加载

优先于对象存在

被类的所有对象共存：如果某个成员变量是被所有对象共享的，那么它就应该定义为静态的

例如：饮水机（用静态修饰），水杯（不能用静态修饰）

**可以通过类名调用:**

其实它本身也可以通过对象名调用。

推荐使用类名调用。

静态修饰的内容一般我们称其为：与类相关的，类成员

static注意事项 在静态方法中是没有this关键字的（静态是随着类的加载而加载的，this
是随着对象的创建而存在，静态比对象先存在）

静态方法只能访问静态的成员变量和和静态的成员方法

静态变量和成员变量的区别：静态变量也叫类变量 成员变量也叫对象变量

所属不同

静态变量属于类，所以也称为为类变量

成员变量属于对象，所以也称为实例变量*(对象变量)*

内存中位置不同

静态变量存储于方法区的静态区

成员变量存储于堆内存

内存出现时间不同

静态变量随着类的加载而加载，随着类的消失而消失

成员变量随着对象的创建而存在，随着对象的消失而消失

调用不同

静态变量可以通过类名调用，也可以通过对象调用

成员变量只能通过对象名调用

main方法的格式详细解释 格式： static void main(String[] args) {}

针对格式的解释:

public 被**jvm**调用，访问权限足够大。

static被**jvm**调用，不用创建对象，直接类名访问

void被**jvm**调用，不需要给**jvm**返回值

main 一个通用的名称，虽然不是关键字，但是被**jvm**识别

**String**[] args 以前用于接收键盘录入的

说明书的制作过程 对工具类加入文档注释

通过javadoc命令生成说明书

**\@author**（提取作者内容）

**\@version**（提取版本内容）

javadoc–d 指定的文件目录 –author –**version** 工具类.java

**\@param**参数名称*//形式参数的变量名称*

**\@return**函数运行完返回的数据

代码块的概述和分类 代码块概述：在Java中，使用{}括起来的代码被称为代码块

代码块分类：根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块（多线程）

局部代码块：在方法中出现；限定变量生命周期，及早释放，提高内存利用率

构造代码块：在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行

静态代码块：在类中方法外出现，并加上**static**修饰；用于给类进行初始化，在加载的时候就执行，并且只执行一次。一般用于加载驱动

**class Student** {

**static**{

System.**out**.println("Student静态代码块");

}

{

System.**out**.println("Student构造代码块");

}

publicStudent() {

System.**out**.println("Student构造方法");

}

}

继承 让类与类之间产生父子类关系，例如：动物类，猫类，狗类

优点：提高代码的复用性以及维护性，是多态的前提

弊端：类的耦合性增强了，开发原则：高内聚，低耦合（耦合：类与类的
关系，内聚：就是自己完成某件事情的能力）

继承特点
java只支持单继承，不支持多继承，java支持多层继承（继承体系，如果想用这个体系的所有功能用最底层的类创建对象，如果想看这个体系的共性功能，看最顶层的类）

继承的注意事项 子类只能继承父类所有非私有的成员（成员变量和成员方法）

子类不能继承父类构造方法，但可以通过super关键字去访问父类构造方 法

不要为了部分功能而去继承

继承其实体现的是一种关系:”is a”，如果有两个类**A**，B，只有他们符合
**A**是B的一种，或者B是**A**的一种，就可以考虑使用继承（水果：苹果， 香蕉…）

this和super的区别和应用 this：代表当前对象的引用，谁来调用我，我就代表谁

**super**：代表当前对象父类的引用

区别：

调用成员变量：

this.成员变量 调用本类的成员变量,也可以调用父类的成员变量（ 本类没有的情况下）

super.成员变量 调用父类的成员变量

调用构造方法

this(...) 调用本类的构造方法

super(...) 调用父类的构造方法

调用成员方法

this.成员方法 调用本类的成员方法,也可以调用父类的方法

super.成员方法 调用父类的成员方法

继承中构造方法的关系
子类中所有的构造方法默认都会访问父类中空参数的构造方法，因为子类会继承父类中的数据，可能还会使用父类的数据，所以子类初始化之前，一定要先完成父类数据的初始化，其实每一个构造方法的第一条语句默认都是：super()
Object类最顶层的父类

继承中构造方法的注意事项
如果父类没有无参构造子类可以调用super（调用父类中的构造方法），
this（调用本类中的构造方法）解决

继承中成员方法的关系：不同名方法：子类可以调用父类的方法，同名方法：优先使用子类方法（重写）

方法重写概述及其应用

重写：子父类出现了一模一样的方法（返回值类型可以是子父类）

应用：当子类需要父类的功能，而功能主体子类有自己特有内容，可以重写父类中的方法。这样，即沿袭了父类的功能，又定义了子类特有的内容，可以重写父类中的方法。这样，即沿袭了父类的功能，又定义了子类特有的内容

方法重写注意事项

父类中私有方法不能被重写，因为父类私有方法子类根本无法继承

子类重写父类方法时，访问权限不能更低，最好一致

父类静态方法，子类也必须通过静态方法进行重写（静态只能覆盖静态）

子类重写父类方法的时候，最好声明一模一样

方法重写（Override）和方法重载（Overload）的区别

方法重写：子类中出现了和父类中方法声明一模一样的方法。与返回值类型有关,返回值是一致*(或者是子父类)*的

方法重载：本类中出现的方法名一样，参数列表不同的方法。与返回值类型无关。可以改变返回值类型,只看参数列表

子类对象调用方法的时候：先找子类本身，再找父类。

final关键字修饰类,方法以及变量的特点 final概述：java中的修饰词，最终的

修饰特点：

修饰类，类不能被继承

修饰变量，变量就变成了常量，只能被赋值一次

修饰方法，方法不能被重写

final关键字修饰局部变量 基本类型：值不能被改变

引用类型：地址不能被改变，对象中的属性可以改变

final修饰变量初始化时机 显示初始化：final int num =
0；（final修饰赋值，默认值无效）

在对象构造完毕前即可，比如在构造方法中赋值

多态（polymorphic）的概述及其代码体现 多态概述：事物存在的多种形态

多态前提：要有继承关系，要有方法重写，要有父类引用指向子类对象

多态中的成员访问特点 成员变量：编译看左边（父类），运行看左边（父类）

成员方法：编译看左边（父类），运行看右边（子类），动态绑定

静态方法：编译看左边（父类），运行看左边（父类）

只有非静态的成员方法，编译看左边，运行看右边

向上转型：父类引用指向子类对象 Personp = new SuperMan();向上转型

SuperMansm = (SuperMan)p*;向下转型*

多态的优点和弊端 优点：提高代码的可维护性（继承保证），提高代码的扩展性（多态保
证），可以当做形式参数，可以接受任意子类对象

弊端：不能使用子类的特有属性和行为

关键字instanceof：判断前面的引用是否是后面的数据类型（例如： animal instanceof
Cat）

抽象类的概述及其特点 概述：抽象就是看不懂的

抽象类特点：

抽象类和抽象方法必须使用**abstract**关键字修饰

abstract class 类名{};

public abstract void 方法名()；

抽象类不一定有抽象方法，有抽象方法的类一定滴抽象类或者是接口

抽象类不能实例化，按照多态的方式，由具体的子类实例化，其实这也是多态的一种，抽象类多态

抽象类的子类：要么是抽象类，要么重写抽象类中所有的抽象方法

抽象类的成员特点 成员变量：既可以是变量，也可以是常量，abstract不能修饰成员变量

构造方法：有，用于子类访问父类数据的初始化

成员方法：既可以是抽象的，也可以是非抽象的

抽象类的成员方法特性

抽象方法，强制要求子类做的事情（必须重写）

非抽象方法，子类继承的事情，提高代码复用性（子类继承可直接使用）

如果一个抽象类没有抽象方法存在的意义：不让其他类创建本类对象，交给子类完成

abstract不能和那些关键字共存

**static**：被**abstract**修饰的方法没有方法体，被**static**修饰的可以用类名.调用，但是类名.调用抽象方法是没有意义的

**final**：被**final**修饰的不让子类重写，**abstract**是强制要求重写

**private**：被**abstract**修饰的是为了让子类看到并强制重写，被**private**修饰的不让子类访问，所以他两矛盾

接口的概述及其特点
接口的概述：从狭义的角度讲就是java中的interface，从广义的角度讲
对外提供规则的都是接口

接口特点：

接口用关键字**interface**表示：

interface 接口名 {}

类实现接口用**implements**表示：

class 类名 implements 接口名 {}

接口不能实例化，需按照多态的方式来实例化

接口的子类：可以是抽象类（但意义不大），可以是具体的类，要重
写接口中所有的抽象方法（推荐方案）

接口成员的特点 成员变量：只能是常量，并且是静态的并公共的，默认修饰符：public
staticfinal（建议手动给出值）

构造方法：接口没有构造方法

成员方法：只能是抽象方法，默认修饰符：**public abstract**

类，接口相互之间的关系：

类与类：继承关系，只能单继承，可以多层继承（继承体系）

类与接口：实现关系，可以单实现，也可以多实现（继承一个类，实现多个）

接口与接口：继承关系，可以单继承，也可以多继承（继承多个接口）

抽象类和接口的区别 成员区别：

抽象类：

成员变量：可以是变量，也可以是常量

构造方法：有

成员方法：可以抽象，也可以非抽象

接口：

成员变量：只可以是常量

构造方法：无

成员方法：只可以是抽象方法

关系区别：

类与类：继承，单继承

类与接口：实现，单实现，多实现

接口与接口：继承，单继承，多继承

设计理念：

抽象类：被继承体现的是：“is a”的关系，抽象类中定义的是该继 承体系的共性功能

接口：被实现体现的是：“like a”的关系，接口中定义的是该继承 体系的扩展功能

package关键字的概述及作用 概述：存文件的文件夹（将文件按照功能或者模块归类）

作用：将字节码进行分类存放，包其实就是文件夹

包的定义及注意事项 定义包的格式：package 包名，多级包用.分开即可

定义包的注意事项：**package**语句必须是程序的第一条可执行的代码；
**package**语句在一个java文件只能有一个；如果没有**package**默认表示无 包名

带包的类编译和运行 javac编译的时候带上-d即可：javac -d .HelloWorld.java

通过**java**命令执行：**java** 包名.HellWord

import关键字的概述和作用 import：让有包的类对调用者可见，不用写全类名

格式：**import 包名;**（这种方式导入是到类的名称，虽然可以最后写\*，但 不建议）

四种权限修饰符

类及其组成所有使用的常见修饰符 修饰符：

权限修饰符：private、默认的、protected、public

状态修饰符：static、final

抽象修饰符：abstract

类

权限修饰符：默认修饰符，public

状态修饰符：final

抽象修饰符：abstract

用的最多的就是：public

成员变量：

权限修饰符：private，默认的，protected，public

状态修饰符：static，final

用的最多的就是：private

构造方法：

权限修饰符：private，默认的，protected，public

用的最多的就是：public

成员方法：

权限修饰符：private，默认的，protected，public

状态修饰符：static，final

抽象修饰符：abstract

用的最多的就是：public

除此以外的组合规则：

成员变量：public static final

成员方法：

public static

public abstract

publicfinal

内部类概述和访问特点 概述：在类中定义类

特点：

内部类可以直接访问外部类的成员，包括私有

外部类要访问内部类成员，必须创建对象

外部类.内部类 对象名 = 外部类对象.内部类对象；

成员内部类私有使用：

在外部类中创建方法，访问本类中私有的内部类即可

静态成员内部类：

外部类名.内部类名 对象名 = 外部类名.内部类对象;

内部类之所以能获取到外部类的成员，是因为他能获取到外部类的引用：外部类.this

局部内部类访问局部变量的问题：

（局部内部类：方法中定义的内部类，只能在其方法中访问）

局部内部类在访问局部变量必须用**final**修饰，原因：因为当调用这
个方法时,局部变量如果没有用**final**修饰,他的生命周期和方法的生
命周期是一样的,当方法弹栈,这个局部变量也会消失,那么如果局部
内部类对象还没有马上消失想用这个局部变量,就没有了,如果用
**final**修饰会在类加载的时候进入常量池,即使方法弹栈,常量池的常
量还在,也可以继续使用

匿名内部类的格式和理解：

匿名内部类：内部类的简化写法

前提：存在一个类（具体类或者抽象类）或者接口

格式：

**new** 类名或者接口名(){

重写方法;

}

本质：是一个继承了该类或者实现了该接口的子类匿名对象

匿名内部类只针对重写一个方法时候使用

匿名内部类是不能向上转型的，因为没有子类类名

匿名内部类当做参数传递（本质：把匿名内部类看做一个对象）
