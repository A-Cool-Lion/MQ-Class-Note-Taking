**Java中的变量:**

**一、什么是变量: 来源于数学,在程序运行过程中会发生变化的量**

变量的好处:

1. 方便记忆,不用记内存地址编码

2. 更有意义,操作起来更简单、方便

**二、Java的数据类型**

Java中数据类型分为两大类:

1. 基本数据类型

2. 引用数据类型

在前期的Java基础中,基本数据类型都会学到

引用数据类型只会学到一种: **String** 字符串

Java八种基本数据类型:

整型: byte(8位1字节 -128\~127) **short**(16位2字节) int(32位4字节)
**long**(64位8字节)

浮点型: float(32位) **double**(64位)

布尔: boolean 值: **true false**

字符: char 只能存储单个字符

**三、定义变量:**

数据类型 变量名 = 初始值;

(定义**float**类型后面加个F)(定义**long**类型后面加个L)

[**1**]变量命名规则:

1). 由数字、字母、下划线(_)、美元符号(\$)组成

2). 数字不能作为开头

3). 变量名不能与java关键字和保留字一致

[**2**]变量规则:

1. 先声明,再使用

2. 同一个名字的变量,不能在一个程序中声明两次

[**3**]标识符命名规范:

1. 类名规则大驼峰 HelloWord

2. 变量名规则小驼峰 maxValueOfThree

[**4**]数据类型转换:

原则:范围小的数据类型可以自动转换为范围大的数据类型

如果需要把大范围的数赋值给小范围,需要强制转换 语法: 数据类型 变量名 =
(需要转换的类型)值;

[**5**]位运算: System.**out**.println(age \<\< 2);

二进制向前移动两位 后面补0 左移2位10进制数字乘2 左移三位乘8 四位乘32

**java中的运算符**

**算数运算符: + - \* / %**

/ : 结果取商

% : 结果取余

两个不同类型的变量进行运算,结果是精度更高的类型(既表示范围更大的类型)

Demo: **int** a = 10;

**byte** b = 10;

b = b + a ; 会出现报错 把一个**int**类型的转换成了精度小的**byte**类型

**字符串拼接:**

如果 '+' 对字符串做运算 ,那么就代表链接字符串的意思

**自加自减:**

*自加: n*++*/*++*n 对变量自身*+*1*

*自减: n*--*/*--*n 对变量自身*-*1*

**复合运算符: += -= \*= /= %=**

Demo:

**byte** cc = 5*;*

cc += 10*; 这次不会报错 复合运算符会自动进行强制转换* lx:
不借助中间变量交换两个变量的值

int num1 = 20, num2 = 30*;*

num1 = num1 + num2*;*

num2 = num1 - num2*;*

num1 = num1 - num2*;*

注:这样交换的弊端: 两个数太大有可能会超出范围,结果不准确

**关系运算符(比较运算符) : \> \< \>= \<= == !=**

比较两个值得大小关系, 由比较运算符组成的表达式,称之为比较表达式

比较表达式的结果(返回值)是boolean类型,结果只能是true(真)或false(假)

**目运算符(三元运算符):**

变量 = 比较表达式 ? 值1 : 值2;

如果比较表达式的结果为true,那么就把值1赋值给变量

如果比较表达式的结果为false,那么就把值2赋值给变量

lx1: 有两个变量a和b ,取出两个变量中较大的一个

max = a \> b ? a : b;

lx2: 有一个整数a ,计算该值得绝对值

**int** abs = a \>= 0 ? a : -a;

**逻辑运算符:**

逻辑运算符是对其它的关系*(比较)*表达式进行运算

与*(&&)* : 全真才为真,一假则假

或*(\|\|)* : 有一真则为真,一真则真

非*(!)* : 一目运算符*(单目运算符)*直接取反

**位运算符:**

对二进制数进行运算(十进制进行运算之前要转成二进制)

\<\< 左移运算 \>\> 右移运算 \^ 异或运算 & 与运算 \| 或运算

**1). 左移运算:**

**System**.out.println(x \<\< 2);

**0000 1110** 左移两位: **0011100014** (14\*4) **56**

左移两位乘**4** 左移三位乘**8lx**: 如何高效率的判断一个数是偶数:

如果一个数右移一位之后左移一位等于本身那么他就是偶数

代码体现: **System**.out.println(x== x \>\> 1 \<\< 1)

**2). 异或运算:**

比较二进制的每一个位数 一样为1,不一样为0

Demo(不用中间变量交换两个变量的值):

a = a \^ **b** *;*

**b** = a \^ **b** *;*

a = a \^ **b** *;*

**3). 与(&)运算:**

比较二进制的每一个位数, 全是1为1,否则为012的二进制: 0000 110018的二进制: 0001
001012与18比较没有一位是全为1 , 所以 12&18=0000 0000 = 0*;*

**4). 非(\|)运算:**

比较二进制的每一个位数, 有一个1为1,否则为012的二进制: 0000 110018的二进制: 0001
001012\|18运算: 0001 1110 = 30*;*

**java的分支结构**

**if**语句:

语法: **if**(条件){

代码块;

}

条件: 返回值是布尔型**boolean**的表达式的值

代码块: 条件的返回值为**true**的情况下所执行的代码

\***if**--**else**语句:

语法: **if**(条件){

代码块1;

} **else**{

代码块2;

}

如果条件为**true** 执行代码块1,否则执行代码块2

**if**与**else**互斥:要么执行**if**,要么执行**else**

\* **if** -- **else if** 语句

语法: **if**(条件1){

语句块1;

} **else if**(条件2){

语句块2;

} **else if**(条件3){

语句块3;

}

......

......

**else if**(条件n){

语句块n;

}

**else**{

语句块n+1;

}

程序按照顺序执行,直到某一个条件为**true**,执行该条件大括号只的语句块,然后跳出循环

最后的**else**可写可不写

\* **if**的嵌套

语法: **if**(条件1){

**if**(条件2){

}

}**else**{

**if**(条件3)

}

\* **switch** -- **case** 语句:

语法:

**switch**(表达式){

**case** 值1:

代码块1;

**break**;

**case** 值2:

代码块2;

**break**;

**case** 值3:

代码块3;

**break**;

...

...

**case** 值n:

代码块n;

**break**;

**default**:

代码块n+1;

**break**;(**default**中的**break**可加可不加)

}

表达式: 表达式的结果必须可以自动转换为**int**型(**byte char short**)

在JDK1.5版本后, 表达式的结果可以是字符串 或枚举类型(**enum**)

**break** : 跳出 **switch** 结构

执行的过程: 表达式都没有与之对应的值,那么就会执行**default**中的代码块

执行的过程中,遇到**break** 就会跳出**switch**结构

如果该**case**中没有**break** 那么就会顺序执行下一个**case**,
直到遇到**break**或**switch**结构结束为止

\*注意事项:

判断两个字符串是否相等是不能用 == ,需要调用 equals() 方法.

**循环结构:**

**while**循环

语法: **while** (循环条件){

循环语句;

}

执行过程:

先判断循环条件; 如果结果为true,那么就会执行循环体部分代码;

当循环体执行完毕后会再次判断循环条件,如果为true,继续执行循环体的代码.

一直重复上述过程,直到某次循环的条件为false,那么就会跳出循环

附加:

变量的作用域: 变量生效的范围

从变量声明开始,一直到变量声明时所在的大括号{}末尾

在同一个作用域,同一个变量不能声明两次

**do**...**while**循环

语法: **do**{

循环语句;

}**while**(循环条件);

执行过程:

先执行一遍循环体,然后进行条件的判断;

如果条件结果为true,则再次执行循环体.

**do**...**while** 至少会执行一次循环体(与**while**循环明显的区别)

\* **for**循环

语法: **for**(循环变量初始化1;循环条件2;循环变量自增3){

循环体4;

}

执行过程:

执行一次1,判断条件2,如果结果为true则执行4;

4执行完毕会执行3,然后在执行条件2, 开始循环

1→→→ 2 →→→ 4 →→→ 3 →→→ 2 →→→ 4 →→→ 3 →→→ 2 →→→ 4 →→→ 3 ···

\* 注意事项:

在循环过程中, 如果遇到**break**,会直接终止循环.

**数组:**

在Java中,数组就是一个变量,用于将相同数据类型的数据存储在内存中,数组中的每一个元素都属于同一数据类型;

对比变量来说,变量是在内存中分配了一块适合的空间,同样,数组就是在内存中划出一串连续的空间;

数组是在内存中划分一串连续的内存空间.

创建数组时,必须指定数据类型,数据类型指定后不可以发生变化

数组的长度也必须指定,同样指定后不允许发生变化

数组中存在的数据叫做元素

数组中每个元素的位置叫做下标, 注意: 下标从0开始

数组声明的方式:

1). 直接指定了: 数据类型/长度/各个元素的值

[1] **int**[] 数组的名字 = {9,8,17,45,36};

[2] **int** 数组的名字[] = {9,8,17,45,36}; 不建议使用,但是是正确的写法

2). 指明了数组的数据类型和长度

**int**[] 数组的名字 = **new int**[10];

3). 先声明,再赋值

**float**[] array;

array = **new float**[8];

**int**型数组默认值: 0 **boolean**型数组默认值: **false**

**char**类型默认值: [] 引用数据类型数组(String)默认值: **null**

**float**类型数组默认值: 0.0

栈内存:存储变量 堆内存:存储具体数

**int**[] array1 = **new int**[6];

System.out.**println**(array1); 直接输出数组名则输出的为数组的地址
每一个数据类型的数组地址都不相同

*// 为数组下标为2的元素赋值 array1[2] = 200;*

*// 获取数组的长度 调用(.)数组array1的length属性*

System.out.**println**(array1.length);

*// 第二个异常: 数组越界异常(ArrayIndexOutOfBoundsException)*

System.out.**println**(array1[array1.length]);

*// 获取数组的最后一个元素*

System.out.**println**(array1[array1.length - 1]);

数组升序排序方法: Arrays.**sort**(数组名);

遍历数组元素的值: Arrays.toString(数组名);

**java中的面向对象OOP**

*\* 附加: 包名: 公司域名倒序.工程名字*

包名命名规则: 字母必须全小写,不存在驼峰命名.

类的第一条语句:

声明该类所在的包

规则: 该行代码必须写在第一行(不包含空格和注释)

创建工程的时候必须指定包名,

并且所有的类必须都创建在该包或该包的子包下

不允许直接在src文件夹下创建类

*\* 类的关键字 class*

*\* 属性:*

在类中直接声明的变量,就是该类的属性

声明的属性 : 实际上是规定了一种规范; 规范了该类的所有对象,都有这几个属性

*\* 方法(动态特征) : 在某些编程语言中也称之为 函数*

方法的格式:

访问权限修饰符 返回值类型 方法名(参数列表){

方法体;

}

返回值 : 代表该方法执行后的结果. 如果没有返回值, 返回值类型位置添void

方法只有调用才会执行,同一个方法可以调用多次.

*\* 创建类的对象:*

语法: 类名 变量名 = new 构造方法;

一个类可以创建无数个对象

一个对象初始化的过程:

1. 声明变量名

2. 堆内存中划分内存空间

3. 在内存空间中给初始值(给对象初始化)

*\* 类中的对象*

某个类中的所有对象互相都是独立的,改变其中一个对象的状态时,
不会对其它对象产生影响.

当一个对象创建好之后, 会把该对象的所有属性都划分好内存; 换句话说:
对象中的属性都是有初始值的

*\* 第三个异常: 空指针异常 NullPointerException*

发生原因: 调用了某个值为null的对象的方法或属性时, 会抛出空指针异常

*\* 带返回值的方法:*

如果调用某个方法之后,需要有一个执行的结果,

那么该结果就叫做返回值在方法的返回值类型位置明确指出该类型

如果某个方法有返回值类型,那么必须使用**return**关键字, 将方法返回

如果某个方法的返回值类型是void,

那么在方法体中也可以写**return** ,但是后面不能有值,

在某个方法中如果遇到了**return** 那么会直接结束方法,

如果**return**不是必要的,则可以省略

*\* 调用带参数的方法:*

在调用某个带参数的方法时,也必须提供方法所需的参数列表(包括类型和顺序)

形参(形式参数): 方法的参数列表里的参数,只是形式,不做计算

实参(实际参数): 调用方法时实际要提供进行计算的参数.

**构造方法&静态变量__study**

一、 构造方法 :

是一种特殊的方法,没有返回值类型,方法名与类名必须一致.

\* 注意事项:

1). 创建一个类的对象时会调用构造方法

2). 每一个类都有一个隐藏的默认的构造方法,格式如下:

**public** 类名(){

}

3). 如果类中定义了带参数的构造方法(有参构造方法),那么默认的构造方法就会自动消失;

如果必须要使用默认的,就显示的重新书写出来.(无参构造方法)

4). 构造方法支持方法的重载

\* 构造方法的作用:

对类的成员变量进行初始化.

\* 创建一个对象的公式(新):

类名 对象名 = **new** 构造方法;

二、 静态变量 :

被**static**修饰的成员变量为静态变量. 关键字 **static**

\* 注意事项 :

1). 创建一个对象时,实际上系统会先加载对象所属的类;同一个类只会加载一次.

2). 被 **static**
修饰的属性或方法属于类,而不属于对象;所以**static**修饰的属性或方法

可以直接通过类名调用;当类调用时方法名为斜体.

\* 静态变量的特点:

1). **static**修饰的属性或方法直接用类名进行调用.

2). **static**修饰的变量,被类中所有的对象共享.

3). 普通方法可以调用静态方法,静态方法"只能"调用静态方法.

因为静态方法是类的,系统会先加载类,后加载类的对象态变量加载之后,

普通方法还没有加载,所以静态方法不能调用普通方法.若想调用必须创建一个对象来进行调用

\* 什么时候使用静态方法:

1). 当方法中不需要引用成员变量的时候,这个方法可以定义为静态方法.

2). 工具方法一般都会声明成静态的(例:**Math**类中的方法)

\* 方法的格式: **0**个或多个修饰符 返回值类型 方法名(参数列表){

方法体;

}

**String_字符串:**

字符串实际上是通过封装char得到的;

\* 方法的重载:

在同一个类中,方法名相同;参数列表不同

参数列表不同: 类型、顺序、个数 不同

实际上的原则: 当调用的时候可以明确区分调用的是哪一个方法即可.

\* 字符串的常用方法:(\*\*\*每个方法都不对原字符串(str)造成影响\*\*\*)

1. 获取字符串的长度:

str.length();

2. 获取字符串中index位置的字符:

str.charAt(index);

3. 获取某一个字符在字符串中第一次出现的下标:

str.indexOf();

带两个参数的方法 indexOf("查询的字符串",开始查询的位置);

indexOf()可以查询单个字符,也可以查询字符串.

4. 判断字符串中是否包含某个子字符串:

str.contains("子字符串");

5. 判断某个字符串是不是以xxxx开头:

str.startsWith("xxxx");

6. 判断某个字符串是不是以xxxx结尾:

str.endsWith("xxxx");

7. 检索某个字符在字符串中最后出现的位置:

str.lastindexOf("单个字符或字符串");

四个方法的重载,用法和indexOf()一致.

8. 将字符串中的某个字符/字符串都替换为新字符/字符串:

str.replace("需要替换的字符或字符串","替换成的新字符或字符串");

str.replaceAll(**String** regex, **String** replace);

将满足某个正则表达式的子串都替换为某个新的字符串(子串)

9. 判断某个字符串是否为空:

str.isEmpty(); 返回值为boolean类型

10. 截取字符串 [beginIndex, endIndex) :

str.substring(beginIndex,endIndex) [前闭后开)

11. 字符串字母大小写转换:

str.toLowerCase() 把字符串中的英文都转换成小写

str.toUpperCase() 把字符串中的英文都转换成大写

12. 去掉字符串的首尾所有空格, 中间的不去掉:

str.trim();

13. 将字符串转换为字节数组:

str.getBytes();

14. 将字符串转换为字符数组:

str.toCharArray();

15. 根据正则表达式把字符串分隔为字符串的数组 :

str.sqlit("a"); 按'a'字符进行分割,分割后不包含'a'字符.

16. 判断两个字符串的内容是否一样 :

str.equals(str2); 返回值为boolean类型

17. 忽略大小写来判断两个字符串的内容是否一样( 实例:验证码 ) :

str.equalsIgnoreCase(str2); 返回值为boolean类型

**常用类以及方法**

一、可变字符串:

**StringBuilder** 与 **StringBuffer**

创建**StringBuider的对象:**

**StringBuider** sb = new **StringBuider("初始内容");**

\* **StringBuider类的方法:(只有replace方法不会改变原字符串对象)**

1. 字符串的拼接:

sb.append("拼接的内容")*;*

2. **StringBuider类型转换为String类型:**

sb.toString()*;*

3. 从index下标位置开始截取字符串:

sb.**substring(index);**

该方法是有返回值的,声明**String对象接收**

该方法不会对原来的对象造成更改

4. 把从[**strat,end)部分的字符串替换为** "新定义的字符串":

sb.replace(start,**end**)*;*

5. 把字符串倒置:

sb.**reverse();**

6. 向下标为index处插入字符串/字符*;*

sb.insert(index,"字符串/字符")*;*

\* **StringBuffer** 与 **StringBuilder** 里面的方法和使用方式完全一样

\* StirngBuffer与**StringBuilder的区别:**

1). 在多线程的情况下优先使用**StringBuffer,因为它是线程安全的保障**

2). 在单线程的情况下优先使用**StringBuilder,因为它的效率比StringBuffer高**

二、Math:

提供了一些常用的数学计算方法*; 是一个工具类*

\* 计算绝对值:

Math.abs(-88)*;*

\* 计算次方:

Math.pow(2,3)*;*

\* 返回一个[0,1)的随机数: random()*;*

double random = Math.random()*;*

\* 获取一个[1,100]的整数:

int randomInt = (int)(Math.random() \* 100) + 1*;*

\* 获取PI:

Math.PI()*;*

**继承: 关键字:extends**

如果多个类中有多个相同的属性或相同的方法,那么就可以定义一个这些类的父类,这些类去继承这个父类

*\* 继承的特点:*

1). 在Java中如果一个类没有明确指定父类的类型,那么它就继承Object对象

2). Java中类是单继承的;既一个子类只能有一个直接父类

*\* 注意事项:*

1). 如果父类的属性是private,那么子不能直接调用该属性;

但是可以使用父类的getter&setter方法间接的使用该属性.

2). 在创建一个对象的时候,使用构造方法时,一定会先调用父类的构造方法.

*\* 方法的重写(覆写):*

在子类中可以把父类集成的方法重写一遍,重写后父类的方法会被覆盖.(子类重写方法的访问权限不能比父类更严格)

如果想要保留父类的方法,可以在重写的方法体中用super关键字来调用.

构造方法不能重写,因为构造方法的名字必须与类名相同.

*\* final关键字:*

final关键字可以修饰 类/方法/属性

1). 修饰类: 那么这个类不能被继承

2). 修饰方法: 那么这个方法不能被重写(覆写)

3). 修饰属性: 那么这个属性的值不能被改变

*\* 附加:*

直接打印一个对象时,实际上是在打印该对象的**toString**()方法.

我们可以自己去重写**toString**()方法

*\* 面试题: 子类能继承父类的私有属性吗?*

不能回答的太绝对: 子类可以通过使用父类的getter & setter 来间接使用父类私有属性

**多态:**

*\* 多态存在的前提条件:*

存在继承关系

*\* 多态的原则:*

当调用某个对象的某个方法时,系统会看这个对象的真实类型是什么.

而且调用的永远都是这个真实对象的方法.

*\* 多态的表现形式:*

1). 父类声明对象由子类初始化(父类声明的对象由子类来创建)

2).
如果一个方法的参数中需要传递某个类型的参数,那么该类型的子类对象都可以充当这个方法的

参数进行传递.

3). 如果一个方法的返回值是某个类型,那么该类型的子类对象都可以充当返回值

*\* instanceof:*

用于判断对象的具体类型,通常在向下转型前用于强壮性的判断

A instanceof B : 判断A是否为B类型

**10 抽象类**

抽象类:

1).
如果一个类中有抽象方法,那么该类一定是抽象类.(如果一个类是抽象类,该类不一定有抽象方法)

2). 抽象类的作用就是规定了父类知道有某个方法,但是不知道具体怎么执行

3). 如果一个类(普通类)继承了抽象类,那么必须抽象类的所有抽象方法

4). 抽象类不能创建对象.

5). 一个抽象类可以继承一个抽象类

\* 注意事项:

同一个类不能同时被 **final** 和 **abstract** 修饰.

**final**修饰的类不能被继承,而**abstract**修饰的必须得有子类去继承它.

\* 匿名内部类对象

因为Hero是抽象类,所以不能直接创建Hero类型的对象

下面代表创建了一个没有名的类继承了Hero类,并且重写了Hero的两个方法\*/

Hero hero = **new** Hero("") {

**\@Override**

**public void attack**() {

System.out.println("匿名的攻击方法");

}

**\@Override**

**public void move**() {

}

};

\* 模板方法模式: 一种设计模式

在父类中定义了大致的流程,具体的流程不太确定,由子类自己去设计流程.
